<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>HOME</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: black;
      overflow: hidden;
    }
    canvas {
      display: block;
    }
    @font-face {
      font-family: 'FightFont';
      src: url('Fonts/Fight!.woff') format('woff');
    }
  </style>
</head>
<body>
<canvas id="homeCanvas"></canvas>
<script>
(() => {
  const player1Keys = ["W", "A", "S", "D", "Q", "E"]
  const player2Keys = ["I", "J", "K", "L", "U", "O"]
  const player3Keys = ["ArrowUp", "ArrowLeft", "ArrowDown", "ArrowRight", "/", "."]
  const player4Keys = ["8", "4", "5", "6", "7", "9"]
  const player5Keys = ["T", "F", "G", "H", "R", "Y"]
  const player6Keys = ["Z", "X", "C", "V", "A", "S"]

  const canvas = document.getElementById("homeCanvas")
  const ctx = canvas.getContext("2d")

  const hexagonRadius = 80
  const centerIndex = 0
  let allHexagons = []

  let gameState = 'MAIN_MENU'; // 'MAIN_MENU', 'PLAYER_COUNT_OPTIONS', 'CHARACTER_SELECTION'
  let maxPlayers = 2; // Default to 2 players

  const ringColors = ["#ff0033", "#00aaff", "#00ff7f", "#ff9900", "#9932cc", "#ff1493"]
  const playerKeyMap = {
    P1: { movement: [player1Keys[1].toLowerCase(), player1Keys[3].toLowerCase()], join: [player1Keys[0].toLowerCase()], color: ringColors[0] },
    P2: { movement: [player2Keys[1].toLowerCase(), player2Keys[3].toLowerCase()], join: [player2Keys[0].toLowerCase()], color: ringColors[1] },
    P3: { movement: [player3Keys[1].toLowerCase(), player3Keys[3].toLowerCase()], join: [player3Keys[0].toLowerCase()], color: ringColors[2] },
    P4: { movement: [player4Keys[1], player4Keys[3]], join: [player4Keys[0]], color: ringColors[3] },
    P5: { movement: [player5Keys[1].toLowerCase(), player5Keys[3].toLowerCase()], join: [player5Keys[0].toLowerCase()], color: ringColors[4] },
    P6: { movement: [player6Keys[1].toLowerCase(), player6Keys[3].toLowerCase()], join: [player6Keys[0].toLowerCase()], color: ringColors[5]}
  }

  const bgPaths = [
    "Assets/Background1/Battleground1.png",
    "Assets/Background2/Battleground2.png",
    "Assets/Background3/Battleground3.png",
    "Assets/Background4/Battleground4.png",
    "Assets/Background5/Battleground5.png",
    "Assets/Background6/Battleground6.png",
    "Assets/Background7/Battleground7.png",
    "Assets/Background8/Battleground8.png"
  ]

  const bgImage = new Image()
  bgImage.src = bgPaths[Math.floor(Math.random() * bgPaths.length)]
  let bgX = 0
  const bgSpeed = 1

  const players = {}

  const characterSprites = [
    { name: "Wu", path: "Assets/Wu/Idle.png", frameCount: 8, frameWidth: 200, frameHeight: 200, row: 0, size: 7 },
    { name: "Tarzan", path: "Assets/Tarzan/Idle.png", frameCount: 10, frameWidth: 126, frameHeight: 126, row: 0, size: 4 },
    { name: "Knight", path: "Assets/Knight/IDLE.png", frameCount: 7, frameWidth: 96, frameHeight: 84, row: 0, size: 4 },
    { name: "Assasin", path: "Assets/Assasin/Idle.png", frameCount: 4, frameWidth: 200, frameHeight: 200, row: 0, size: 7 },
    { name: "Darkrai", path: "Assets/Darkdude.png", frameCount: 6, frameWidth: 80, frameHeight: 80, row: 0, size: 4 },
    { name: "Reaper", path: "Assets/Reaper.png", frameCount: 8, frameWidth: 80, frameHeight: 80, row: 0, size: 4 }
  ]
  const TOTAL_CHARACTER_SLOTS = characterSprites.length; // This is 6

  const spriteImages = characterSprites.map(char => {
    const img = new Image()
    img.src = char.path
    return { ...char, img }
  })

  const bannerImg = new Image()
  bannerImg.src = "Assets/banner.png" // Corrected path to lowercase 'banner'

  const buttonImg = new Image()
  buttonImg.src = "Assets/Button.png" // Top-right "START" button

  const buttonsImage = new Image()
  buttonsImage.src = "Assets/Buttons.png" // Main "PLAY" button graphic


  // Button definitions
  const mainMenuButtons = {
      play: {
          // These are points from the original polygon for the "PLAY" image
          poly: [{ x: 855, y: 82 }, { x: 571, y: 98 }, { x: 518, y: 151 }, { x: 590, y: 227 }, { x: 862, y: 205 }],
          img: buttonsImage // The large "PLAY" button graphic
      },
      options: {
          // Positioned below the main play button
          rect: { x: canvas.width / 2 - 75, y: canvas.height / 2 + 100, width: 150, height: 50 },
          text: "OPTIONS"
      }
  };

  const playerCountOptionsButtons = {
      playerCounts: [
          { label: "2 PLAYERS", value: 2, rect: { x: canvas.width / 2 - 250, y: canvas.height / 2 - 50, width: 150, height: 50 } },
          { label: "3 PLAYERS", value: 3, rect: { x: canvas.width / 2 - 75, y: canvas.height / 2 - 50, width: 150, height: 50 } },
          { label: "4 PLAYERS", value: 4, rect: { x: canvas.width / 2 + 100, y: canvas.height / 2 - 50, width: 150, height: 50 } },
          { label: "5 PLAYERS", value: 5, rect: { x: canvas.width / 2 - 250, y: canvas.height / 2 + 20, width: 150, height: 50 } },
          { label: "6 PLAYERS", value: 6, rect: { x: canvas.width / 2 - 75, y: canvas.height / 2 + 20, width: 150, height: 50 } },
      ],
      back: {
          rect: { x: canvas.width / 2 + 100, y: canvas.height / 2 + 20, width: 150, height: 50 },
          text: "BACK"
      }
  };

  let spriteIndex = 0
  let spriteTimer = 0
  const spriteDelay = 100

  function resizeCanvas() {
    canvas.width = window.innerWidth
    canvas.height = window.innerHeight
    // Recalculate options button position on resize
    mainMenuButtons.options.rect.x = canvas.width / 2 - mainMenuButtons.options.rect.width / 2;
    playerCountOptionsButtons.playerCounts[0].rect.x = canvas.width / 2 - 250;
    playerCountOptionsButtons.playerCounts[1].rect.x = canvas.width / 2 - 75;
    playerCountOptionsButtons.playerCounts[2].rect.x = canvas.width / 2 + 100;
    playerCountOptionsButtons.playerCounts[3].rect.x = canvas.width / 2 - 250;
    playerCountOptionsButtons.playerCounts[4].rect.x = canvas.width / 2 - 75;
    playerCountOptionsButtons.back.rect.x = canvas.width / 2 + 100;
  }

  window.addEventListener("resize", resizeCanvas)
  resizeCanvas() // Initial call to set sizes

  canvas.addEventListener("click", e => {
    const r = canvas.getBoundingClientRect()
    const x = e.clientX - r.left
    const y = e.clientY - r.top
    const p = { x, y }

    if (gameState === 'MAIN_MENU') {
        // Click on "PLAY" button (large image)
        if (isPointInPolygon(p, mainMenuButtons.play.poly)) {
            gameState = 'CHARACTER_SELECTION';
            setupHexagons();
            // Clear current players when entering character selection from main menu
            for (const key in players) {
                if (players.hasOwnProperty(key)) {
                    delete players[key];
                }
            }
        }
        // Click on "OPTIONS" button
        else if (isPointInRect(p, mainMenuButtons.options.rect)) {
            gameState = 'PLAYER_COUNT_OPTIONS';
        }
    } else if (gameState === 'PLAYER_COUNT_OPTIONS') {
        // Click on player count buttons
        for (const btn of playerCountOptionsButtons.playerCounts) {
            if (isPointInRect(p, btn.rect)) {
                maxPlayers = btn.value;
                console.log(`Max players set to ${maxPlayers}`);
                // Remove players beyond the new maxPlayers limit
                Object.keys(players).forEach(id => {
                    const playerNum = parseInt(id.replace('P', ''));
                    if (playerNum > maxPlayers) {
                        delete players[id];
                    }
                });
                gameState = 'MAIN_MENU'; // Return to main menu after selection
                return; // Exit loop and handler
            }
        }
        // Click on "BACK" button
        if (isPointInRect(p, playerCountOptionsButtons.back.rect)) {
            gameState = 'MAIN_MENU';
        }
    } else if (gameState === 'CHARACTER_SELECTION') {
        // "START GAME" button (top right)
        if (x >= canvas.width - 120 && y <= 80) {
            const payload = Object.entries(players).map(([id, p]) => ({
                id,
                character: p.character
            }));

            // Filter out players who are still on the center hexagon (haven't picked a character)
            const activePlayers = payload.filter(player => players[player.id].hex !== centerIndex);

            if (activePlayers.length === 0) {
                alert("Please select at least one character to start the game!");
                return;
            }

            sessionStorage.setItem("fighters", JSON.stringify(activePlayers));

            const controls = {
                P1: player1Keys,
                P2: player2Keys,
                P3: player3Keys,
                P4: player4Keys,
                P5: player5Keys,
                P6: player6Keys
            }
            sessionStorage.setItem("controls", JSON.stringify(controls));

            sessionStorage.setItem("playerCount", activePlayers.length);
            location.href = "game.html";
        }
    }
  })

  window.addEventListener("keydown", e => {
    // Only process keydowns for character selection if in the correct game state
    if (gameState !== 'CHARACTER_SELECTION') {
        return;
    }

    const key = e.key.toLowerCase()
    Object.entries(playerKeyMap).forEach(([id, data]) => {
      const playerNum = parseInt(id.replace('P', ''));

      // Check if this player (P1, P2, etc.) is allowed based on maxPlayers
      if (playerNum > maxPlayers) {
        return; // This player's keys are not active for the current maxPlayers setting
      }

      // Joining a character
      if (!players[id] && data.join.includes(key)) {
        if (Object.keys(players).length < maxPlayers) {
            players[id] = { hex: centerIndex, character: "" }; // Initialize with no character selected
            console.log(`${id} joined. Current players: ${Object.keys(players).length}`);
        } else {
            console.log(`Cannot join, max players (${maxPlayers}) reached.`);
        }
        return;
      }

      // Moving character selection
      const player = players[id]
      if (player && data.movement.includes(key)) {
        const moveRight = data.movement.indexOf(key) === 1
        let next = player.hex;

        // If currently on center (0), moving right goes to 1, moving left goes to last character slot
        if (player.hex === centerIndex) {
            next = moveRight ? 1 : TOTAL_CHARACTER_SLOTS;
        } else {
            // Otherwise, cycle through the outer hexagons (1 to TOTAL_CHARACTER_SLOTS)
            if (moveRight) {
                next = (player.hex % TOTAL_CHARACTER_SLOTS) + 1;
            } else {
                next = (player.hex - 1 === 0) ? TOTAL_CHARACTER_SLOTS : player.hex - 1;
            }
        }
        
        players[id].hex = next;
        // If moving back to center hex (0), it means they left character selection
        if (next === centerIndex) { // This condition should ideally not be reached with the new logic, but kept as a safeguard
          delete players[id];
        } else {
          // Adjust spriteImages index: characterSprites[next - 1] since array is 0-indexed
          const sprite = characterSprites[next - 1];
          players[id].character = sprite?.name || "";
        }
      }
    })
  })

  function setupHexagons() {
    const cx = canvas.width / 2
    const cy = canvas.height / 2
    const distanceToOuterHex = hexagonRadius * Math.sqrt(3) // Distance from center to center of outer hexagon
    allHexagons = [
      generateHexagon(cx, cy) // Center hexagon (index 0)
    ]
    // Generate 6 outer hexagons in a perfect circle around the center
    for (let i = 0; i < TOTAL_CHARACTER_SLOTS; i++) { // TOTAL_CHARACTER_SLOTS is 6
        // Angle starts at top-right and goes clockwise for the image provided
        const angle = (Math.PI / 3) * i - (Math.PI / 6); // Adjust starting angle to match typical hex grid
        allHexagons.push(generateHexagon(
            cx + distanceToOuterHex * Math.cos(angle),
            cy + distanceToOuterHex * Math.sin(angle)
        ));
    }
    console.log(`Generated ${allHexagons.length} hexagons (1 center + ${TOTAL_CHARACTER_SLOTS} outer).`);
  }

  function generateHexagon(cx, cy) {
    const pts = []
    for (let i = 0; i < 6; i++) {
      // Hexagon points are generated starting from the top point, going clockwise
      const angle = Math.PI / 3 * i + Math.PI / 2; // Start at top (90 degrees)
      pts.push({ x: cx + hexagonRadius * Math.cos(angle), y: cy + hexagonRadius * Math.sin(angle) })
    }
    return pts
  }

  function isPointInPolygon(p, poly) {
    let x = p.x, y = p.y, inside = false
    for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
      let xi = poly[i].x, yi = poly[i].y
      let xj = poly[j].x, yj = poly[j].y
      let intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)
      if (intersect) inside = !inside
    }
    return inside
  }

  function isPointInRect(p, rect) {
      return p.x >= rect.x && p.x <= rect.x + rect.width &&
             p.y >= rect.y && p.y <= rect.y + rect.height;
  }

  function drawCharacter(char, hex) {
    if (!char.img.complete) return
    const frameW = char.frameWidth, frameH = char.frameHeight
    const frameX = (spriteIndex % char.frameCount) * frameW
    const frameY = (char.row || 0) * frameH
    const cx = (hex[0].x + hex[3].x) / 2
    const cy = (hex[0].y + hex[3].y) / 2
    const size = hexagonRadius * char.size
    ctx.save()
    ctx.beginPath()
    ctx.moveTo(hex[0].x, hex[0].y)
    for (let j = 1; j < hex.length; j++) ctx.lineTo(hex[j].x, hex[j].y)
    ctx.closePath()
    ctx.clip()
    ctx.drawImage(char.img, frameX, frameY, frameW, frameH, cx - size / 2, cy - size / 2, size, size)
    ctx.restore()
  }

  function drawHex(hex, fill = null, stroke = "#fff", strokeWidth = 3) {
    ctx.beginPath()
    ctx.moveTo(hex[0].x, hex[0].y)
    for (let i = 1; i < hex.length; i++) ctx.lineTo(hex[i].x, hex[i].y)
    ctx.closePath()
    if (fill) {
      ctx.fillStyle = fill
      ctx.fill()
    }
    ctx.lineWidth = strokeWidth
    ctx.strokeStyle = stroke
    ctx.stroke()
  }

  function drawBanners() {
    const activePlayers = Object.entries(players).filter(([id, p]) => p.hex !== centerIndex);
    const numActivePlayers = activePlayers.length;
    const centerX = canvas.width / 2
    const margin = 260 // Spacing between banners

    // Always display banners for maxPlayers, but only when in CHARACTER_SELECTION state
    for (let i = 1; i <= maxPlayers; i++) { // Loop for P1, P2, ... PmaxPlayers
        const id = `P${i}`;
        const p = players[id];

        // Calculate offset to center the group of banners
        const offset = (i - 1 - (maxPlayers - 1) / 2) * margin;
        const x = centerX + offset - 100; // Position banner relative to center
        const y = 30;

        ctx.drawImage(bannerImg, x, y, 200, 70);
        ctx.font = "24px FightFont";
        ctx.textAlign = "center";
        ctx.lineWidth = 4;
        ctx.strokeStyle = "black";
        ctx.fillStyle = "white";

        let titleText = `PLAYER ${i}:`;
        let charText = "CHOOSE A HERO";

        if (p && p.hex !== centerIndex) { // If player exists and has chosen a character
            charText = (p.character || "").toUpperCase();
        }

        ctx.strokeText(titleText, x + 100, y + 28);
        ctx.fillText(titleText, x + 100, y + 28);
        ctx.strokeText(charText, x + 100, y + 58);
        ctx.fillText(charText, x + 100, y + 58);
    }
  }

  // Helper function to draw a button with text
  function drawTextButton(rect, text, isSelected = false) {
    ctx.font = "24px FightFont";
    ctx.textAlign = "center";
    ctx.lineWidth = 3;
    ctx.strokeStyle = "black";
    ctx.fillStyle = "white";

    ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);
    ctx.fillRect(rect.x, rect.y, rect.width, rect.height);
    ctx.strokeText(text, rect.x + rect.width / 2, rect.y + rect.height / 2 + 8);
    ctx.fillText(text, rect.x + rect.width / 2, rect.y + rect.height / 2 + 8);

    if (isSelected) {
        ctx.fillStyle = "yellow";
        ctx.fillRect(rect.x, rect.y - 5, rect.width, 5); // A small bar above the selected button
    }
  }


  function loop(ts = 0) {
    bgX += bgSpeed
    if (bgX >= canvas.width) bgX = 0

    ctx.clearRect(0, 0, canvas.width, canvas.height)
    ctx.drawImage(bgImage, -bgX, 0, canvas.width, canvas.height)
    ctx.drawImage(bgImage, canvas.width - bgX, 0, canvas.width, canvas.height)
    ctx.imageSmoothingEnabled = false // Keep this for pixel art

    if (gameState === 'MAIN_MENU') {
        if (mainMenuButtons.play.img.complete) {
            // The image is typically drawn from its top-left corner, adjust position to center it
            // Assuming buttonsImage is 600x600 and covers the main "Play" area
            const imgW = 600;
            const imgH = 600;
            const imgX = canvas.width / 2 - imgW / 2;
            const imgY = canvas.height / 2 - imgH / 2;
            ctx.drawImage(mainMenuButtons.play.img, imgX, imgY, imgW, imgH);
        }
        // Draw "OPTIONS" button
        drawTextButton(mainMenuButtons.options.rect, mainMenuButtons.options.text);

    } else if (gameState === 'PLAYER_COUNT_OPTIONS') {
        // Draw player count selection buttons
        playerCountOptionsButtons.playerCounts.forEach(btn => {
            drawTextButton(btn.rect, btn.label, btn.value === maxPlayers);
        });
        // Draw "BACK" button
        drawTextButton(playerCountOptionsButtons.back.rect, playerCountOptionsButtons.back.text);

    } else if (gameState === 'CHARACTER_SELECTION') {
      if (ts - spriteTimer > spriteDelay) {
        spriteTimer = ts
        spriteIndex++
      }

      allHexagons.forEach((hex, i) => {
        if (i !== centerIndex) { // Draw outer hexagons
          drawHex(hex, "black")
          drawCharacter(spriteImages[i - 1], hex) // Use i-1 for spriteImages index
          Object.entries(players).forEach(([id, p]) => {
            if (p.hex === i) {
              const color = playerKeyMap[id]?.color
              drawHex(hex, null, color, 5) // Highlight selected character
            }
          })
        }
      })

      const centerHex = allHexagons[centerIndex]
      drawHex(centerHex, "black") // Draw center hexagon
      Object.entries(players).forEach(([id, p]) => {
        if (p.hex === centerIndex) {
          const color = playerKeyMap[id]?.color
          drawHex(centerHex, null, color, 5) // Highlight player in center (not selected a character)
        }
      })

      drawBanners() // Draw banners only in character selection state

      // Draw "START" button (top right)
      ctx.drawImage(buttonImg, canvas.width - 120, 20, 90, 60)
    }

    requestAnimationFrame(loop)
  }

  requestAnimationFrame(loop)
})()
</script>
</body>
</html>
