<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>HOME</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: black;
      overflow: hidden;
    }
    canvas {
      display: block;
    }
    @font-face {
      font-family: 'FightFont';
      src: url('Fonts/Fight!.woff') format('woff');
    }
  </style>
</head>
<body>
<canvas id="homeCanvas"></canvas>
<script>
(() => {
  const player1Keys = ["W", "A", "S", "D", "Q", "E"]
  const player2Keys = ["I", "J", "K", "L", "U", "O"]
  const player3Keys = ["ArrowUp", "ArrowLeft", "ArrowDown", "ArrowRight", "/", "."]
  const player4Keys = ["8", "4", "5", "6", "7", "9"]
  const player5Keys = ["T", "F", "G", "H", "R", "Y"]
  const player6Keys = ["Z", "X", "C", "V", "A", "S"]

  const canvas = document.getElementById("homeCanvas")
  const ctx = canvas.getContext("2d")

  const hexagonRadius = 80
  const centerIndex = 0
  let allHexagons = []
  let showHexagons = false
  let maxPlayers = 2; // Default to 2 players

  const ringColors = ["#ff0033", "#00aaff", "#00ff7f", "#ff9900", "#9932cc", "#ff1493"]
  const playerKeyMap = {
    P1: { movement: [player1Keys[1].toLowerCase(), player1Keys[3].toLowerCase()], join: [player1Keys[0].toLowerCase()], color: ringColors[0] },
    P2: { movement: [player2Keys[1].toLowerCase(), player2Keys[3].toLowerCase()], join: [player2Keys[0].toLowerCase()], color: ringColors[1] },
    P3: { movement: [player3Keys[1].toLowerCase(), player3Keys[3].toLowerCase()], join: [player3Keys[0].toLowerCase()], color: ringColors[2] },
    P4: { movement: [player4Keys[1], player4Keys[3]], join: [player4Keys[0]], color: ringColors[3] },
    P5: { movement: [player5Keys[1].toLowerCase(), player5Keys[3].toLowerCase()], join: [player5Keys[0].toLowerCase()], color: ringColors[4] },
    P6: { movement: [player6Keys[1].toLowerCase(), player6Keys[3].toLowerCase()], join: [player6Keys[0].toLowerCase()], color: ringColors[5]}
  }

  const bgPaths = [
    "Assets/Background1/Battleground1.png",
    "Assets/Background2/Battleground2.png",
    "Assets/Background3/Battleground3.png",
    "Assets/Background4/Battleground4.png",
    "Assets/Background5/Battleground5.png",
    "Assets/Background6/Battleground6.png",
    "Assets/Background7/Battleground7.png",
    "Assets/Background8/Battleground8.png"
  ]

  const bgImage = new Image()
  bgImage.src = bgPaths[Math.floor(Math.random() * bgPaths.length)]
  let bgX = 0
  const bgSpeed = 1

  const players = {}

  const characterSprites = [
    { name: "Wu", path: "Assets/Wu/Idle.png", frameCount: 8, frameWidth: 200, frameHeight: 200, row: 0, size: 7 },
    { name: "Tarzan", path: "Assets/Tarzan/Idle.png", frameCount: 10, frameWidth: 126, frameHeight: 126, row: 0, size: 4 },
    { name: "Knight", path: "Assets/Knight/IDLE.png", frameCount: 7, frameWidth: 96, frameHeight: 84, row: 0, size: 4 },
    { name: "Assasin", path: "Assets/Assasin/Idle.png", frameCount: 4, frameWidth: 200, frameHeight: 200, row: 0, size: 7 },
    { name: "Darkrai", path: "Assets/Darkdude.png", frameCount: 6, frameWidth: 80, frameHeight: 80, row: 0, size: 4 },
    { name: "Reaper", path: "Assets/Reaper.png", frameCount: 8, frameWidth: 80, frameHeight: 80, row: 0, size: 4 }
  ]
  const TOTAL_CHARACTER_SLOTS = characterSprites.length; // This will be 6

  const spriteImages = characterSprites.map(char => {
    const img = new Image()
    img.src = char.path
    return { ...char, img }
  })

  const bannerImg = new Image()
  bannerImg.src = "Assets/banner.png" // Corrected path to lowercase 'banner'

  const buttonImg = new Image()
  buttonImg.src = "Assets/Button.png"

  const buttonsImage = new Image()
  buttonsImage.src = "Assets/Buttons.png"

  // Updated buttonZones
  const buttonZones = [
    // Play button area (existing, center)
    [
      { x: 855, y: 82 }, { x: 571, y: 98 }, { x: 518, y: 151 },
      { x: 590, y: 227 }, { x: 862, y: 205 }
    ],
    // Player count selection buttons (new positions for 2,3,4,5,6)
    // Using a more structured approach for button positions
    {
        label: "2 Players",
        coords: [{ x: 450, y: 300 }, { x: 550, y: 350 }] // Top-left, Bottom-right for rect
    },
    {
        label: "3 Players",
        coords: [{ x: 560, y: 300 }, { x: 660, y: 350 }]
    },
    {
        label: "4 Players",
        coords: [{ x: 670, y: 300 }, { x: 770, y: 350 }]
    },
    {
        label: "5 Players",
        coords: [{ x: 450, y: 360 }, { x: 550, y: 410 }]
    },
    {
        label: "6 Players",
        coords: [{ x: 560, y: 360 }, { x: 660, y: 410 }]
    }
  ]

  let spriteIndex = 0
  let spriteTimer = 0
  const spriteDelay = 100

  function resizeCanvas() {
    canvas.width = window.innerWidth
    canvas.height = window.innerHeight
  }

  window.addEventListener("resize", resizeCanvas)
  resizeCanvas()

  canvas.addEventListener("click", e => {
    const r = canvas.getBoundingClientRect()
    const x = e.clientX - r.left
    const y = e.clientY - r.top
    const p = { x, y }

    // Play button click (top right) - to start game.html
    if (showHexagons && x >= canvas.width - 120 && y <= 80) {
      const payload = Object.entries(players).map(([id, p]) => ({
        id,
        character: p.character
      }))
      sessionStorage.setItem("fighters", JSON.stringify(payload))

      const controls = {
        P1: player1Keys,
        P2: player2Keys,
        P3: player3Keys,
        P4: player4Keys,
        P5: player5Keys,
        P6: player6Keys
      }
      sessionStorage.setItem("controls", JSON.stringify(controls))

      sessionStorage.setItem("playerCount", Object.keys(players).length) // Send actual number of players who joined
      location.href = "game.html"
    }

    // "Play" button (main game start) in the center of the screen
    if (!showHexagons && isPointInPolygon(p, buttonZones[0])) { // Only clickable when not showing hexagons
      showHexagons = true
      setupHexagons()
      return;
    }

    // Player count selection buttons - only visible and clickable when not in character selection
    if (!showHexagons) {
        for (let i = 1; i < buttonZones.length; i++) {
            const btn = buttonZones[i];
            const btnRect = {
                x: btn.coords[0].x,
                y: btn.coords[0].y,
                width: btn.coords[1].x - btn.coords[0].x,
                height: btn.coords[1].y - btn.coords[0].y
            };
            if (x >= btnRect.x && x <= btnRect.x + btnRect.width &&
                y >= btnRect.y && y <= btnRect.y + btnRect.height) {
                maxPlayers = parseInt(btn.label.split(" ")[0]);
                console.log(`Max players set to ${maxPlayers}`);
                // Remove players beyond the new maxPlayers limit
                Object.keys(players).forEach(id => {
                    const playerNum = parseInt(id.replace('P', ''));
                    if (playerNum > maxPlayers) {
                        delete players[id];
                    }
                });
                break; // Exit loop once a button is clicked
            }
        }
    }
  })

  window.addEventListener("keydown", e => {
    const key = e.key.toLowerCase()
    Object.entries(playerKeyMap).forEach(([id, data]) => {
      const playerNum = parseInt(id.replace('P', ''));

      // Check if player can join (maxPlayers limit)
      if (!players[id] && data.join.includes(key)) {
        if (Object.keys(players).length < maxPlayers) { // Only allow joining if maxPlayers limit not reached
            players[id] = { hex: centerIndex };
            console.log(`${id} joined. Current players: ${Object.keys(players).length}`);
        } else {
            console.log(`Cannot join, max players (${maxPlayers}) reached.`);
        }
        return;
      }

      const player = players[id]
      if (player && data.movement.includes(key)) {
        const moveRight = data.movement.indexOf(key) === 1
        // Hexagon selection should always cycle through all TOTAL_CHARACTER_SLOTS
        let next = player.hex;
        const totalCharacterHexes = TOTAL_CHARACTER_SLOTS; // 6 outer hexagons

        if (moveRight) {
            next = (player.hex === 0) ? 1 : ((player.hex % totalCharacterHexes) + 1);
        } else {
            next = (player.hex === 0) ? totalCharacterHexes : ((player.hex - 1 + totalCharacterHexes) % totalCharacterHexes);
            if (next === 0) next = totalCharacterHexes;
        }

        players[id].hex = next;
        // If moving back to center hex (0), it means they left character selection
        if (next === 0) {
          delete players[id];
        } else {
          // Adjust spriteImages index: characterSprites[next - 1] since array is 0-indexed
          const sprite = characterSprites[next - 1];
          players[id].character = sprite?.name || "";
        }
      }
    })
  })

  function setupHexagons() {
    const cx = canvas.width / 2
    const cy = canvas.height / 2
    const dx = hexagonRadius * Math.sqrt(3)
    const dy = hexagonRadius * 1.5
    allHexagons = [
      generateHexagon(cx, cy) // Center hexagon
    ]
    // Always add 6 outer hexagons for character selection
    for (let i = 0; i < TOTAL_CHARACTER_SLOTS; i++) { // Always 6 hexagons
        const angle = (Math.PI * 2 / TOTAL_CHARACTER_SLOTS) * i + Math.PI / 6;
        allHexagons.push(generateHexagon(cx + dx * Math.cos(angle), cy + dx * Math.sin(angle)));
    }
    console.log(`Generated ${allHexagons.length} hexagons (1 center + ${TOTAL_CHARACTER_SLOTS} outer).`);
  }

  function generateHexagon(cx, cy) {
    const pts = []
    for (let i = 0; i < 6; i++) {
      const angle = Math.PI / 3 * i + Math.PI / 6
      pts.push({ x: cx + hexagonRadius * Math.cos(angle), y: cy + hexagonRadius * Math.sin(angle) })
    }
    return pts
  }

  function isPointInPolygon(p, poly) {
    let x = p.x, y = p.y, inside = false
    // Poly can be an array of points (for the main play button) or an object with coords (for new buttons)
    let points = poly;
    if (poly.coords) { // If it's one of the new button objects
        // Create a rectangular polygon from the top-left and bottom-right coords
        points = [
            {x: poly.coords[0].x, y: poly.coords[0].y},
            {x: poly.coords[1].x, y: poly.coords[0].y},
            {x: poly.coords[1].x, y: poly.coords[1].y},
            {x: poly.coords[0].x, y: poly.coords[1].y}
        ];
    }

    for (let i = 0, j = points.length - 1; i < points.length; j = i++) {
      let xi = points[i].x, yi = points[i].y
      let xj = points[j].x, yj = points[j].y
      let intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)
      if (intersect) inside = !inside
    }
    return inside
  }

  function drawCharacter(char, hex) {
    if (!char.img.complete) return
    const frameW = char.frameWidth, frameH = char.frameHeight
    const frameX = (spriteIndex % char.frameCount) * frameW
    const frameY = (char.row || 0) * frameH
    const cx = (hex[0].x + hex[3].x) / 2
    const cy = (hex[0].y + hex[3].y) / 2
    const size = hexagonRadius * char.size
    ctx.save()
    ctx.beginPath()
    ctx.moveTo(hex[0].x, hex[0].y)
    for (let j = 1; j < hex.length; j++) ctx.lineTo(hex[j].x, hex[j].y)
    ctx.closePath()
    ctx.clip()
    ctx.drawImage(char.img, frameX, frameY, frameW, frameH, cx - size / 2, cy - size / 2, size, size)
    ctx.restore()
  }

  function drawHex(hex, fill = null, stroke = "#fff", strokeWidth = 3) {
    ctx.beginPath()
    ctx.moveTo(hex[0].x, hex[0].y)
    for (let i = 1; i < hex.length; i++) ctx.lineTo(hex[i].x, hex[i].y)
    ctx.closePath()
    if (fill) {
      ctx.fillStyle = fill
      ctx.fill()
    }
    ctx.lineWidth = strokeWidth
    ctx.strokeStyle = stroke
    ctx.stroke()
  }

  function drawBanners() {
    const centerX = canvas.width / 2
    const margin = 260

    // Always display banners for maxPlayers
    for (let i = 1; i <= maxPlayers; i++) { // Loop for P1, P2, ... PmaxPlayers
        const id = `P${i}`;
        const p = players[id];

        const offset = (i - 1 - (maxPlayers - 1) / 2) * margin; // Center the group of banners
        const x = centerX + offset - 100; // Position banner relative to center
        const y = 30;

        ctx.drawImage(bannerImg, x, y, 200, 70);
        ctx.font = "24px FightFont";
        ctx.textAlign = "center";
        ctx.lineWidth = 4;
        ctx.strokeStyle = "black";
        ctx.fillStyle = "white";

        let titleText = "";
        let charText = "";

        if (showHexagons && p && p.hex !== centerIndex) { // If in character selection and player has chosen character
            titleText = `Player ${i}:`;
            charText = (p.character || "").toUpperCase();
        } else { // Initial state or player has not chosen a character
            titleText = `PLAYER ${i}:`;
            charText = "CHOOSE A HERO";
        }

        ctx.strokeText(titleText, x + 100, y + 28);
        ctx.fillText(titleText, x + 100, y + 28);
        ctx.strokeText(charText, x + 100, y + 58);
        ctx.fillText(charText, x + 100, y + 58);
    }
  }


  function loop(ts = 0) {
    bgX += bgSpeed
    if (bgX >= canvas.width) bgX = 0

    ctx.clearRect(0, 0, canvas.width, canvas.height)
    ctx.drawImage(bgImage, -bgX, 0, canvas.width, canvas.height)
    ctx.drawImage(bgImage, canvas.width - bgX, 0, canvas.width, canvas.height)

    drawBanners(); // Always draw banners

    if (showHexagons) {
      if (ts - spriteTimer > spriteDelay) {
        spriteTimer = ts
        spriteIndex++
      }

      allHexagons.forEach((hex, i) => {
        if (i !== centerIndex) { // Always draw all 6 outer hexagons
          drawHex(hex, "black")
          drawCharacter(spriteImages[i - 1], hex) // Use i-1 for spriteImages index
          Object.entries(players).forEach(([id, p]) => {
            if (p.hex === i) {
              const color = playerKeyMap[id]?.color
              drawHex(hex, null, color, 5)
            }
          })
        }
      })

      const centerHex = allHexagons[centerIndex]
      drawHex(centerHex, "black")
      Object.entries(players).forEach(([id, p]) => {
        if (p.hex === centerIndex) {
          const color = playerKeyMap[id]?.color
          drawHex(centerHex, null, color, 5)
        }
      })

    } else {
      if (buttonsImage.complete) ctx.drawImage(buttonsImage, 400, 0, 600, 600)

      // Draw player count selection buttons
      ctx.font = "20px FightFont";
      ctx.textAlign = "center";
      ctx.lineWidth = 3;
      ctx.strokeStyle = "black";
      ctx.fillStyle = "white";

      // Draw player count selection buttons (from buttonZones index 1 onwards)
      for (let i = 1; i < buttonZones.length; i++) {
          const btn = buttonZones[i];
          const x = btn.coords[0].x;
          const y = btn.coords[0].y;
          const width = btn.coords[1].x - btn.coords[0].x;
          const height = btn.coords[1].y - btn.coords[0].y;

          ctx.strokeRect(x, y, width, height);
          ctx.fillRect(x, y, width, height);
          ctx.strokeText(btn.label, x + width / 2, y + height / 2 + 5);
          ctx.fillText(btn.label, x + width / 2, y + height / 2 + 5);

          // Indicate current selection
          if (maxPlayers === parseInt(btn.label.split(" ")[0])) {
              ctx.fillStyle = "yellow";
              ctx.fillRect(x, y - 5, width, 5); // A small bar above the selected button
          }
      }
    }

    ctx.drawImage(buttonImg, canvas.width - 120, 20, 90, 60) // Always draw the top-right play button
    ctx.imageSmoothingEnabled = false
    requestAnimationFrame(loop)
  }

  requestAnimationFrame(loop)
})()
</script>
</body>
</html>
