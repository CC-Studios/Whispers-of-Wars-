<!DOCTYPE html>
<html lang="en">

<head>
    <link rel="icon" type="image/png" href="Assets/Favicon.png" />
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Whispers of War</title>
    <style>
        body, html { margin: 0; padding: 0; overflow: hidden; background: #000; }
        canvas { display: block; background: #000; }
        @font-face {
          font-family: 'FightFont';
          src: url('Fonts/Fight!.woff') format('woff');
        }
    </style>
</head>

<body>
    <canvas id="gameCanvas"></canvas>
    <script>
        (() => {
          const canvas = document.getElementById("gameCanvas");
          const ctx = canvas.getContext("2d");
        
          const BG_TILE_WIDTH = 1600;
          const BG_TILE_HEIGHT = 800;
          const SCALE = 4.5;
          const HSB = 40;
        
          const floatingTexts = [];
          const groundY = 695;
          let cameraX = 0;
        
          let debugMode = false; // Set to false by default
          let pauseGame = false;
          let pausedFrame = null;
          let draggingEllipse = null;
          let resizingEllipse = null;
          let draggingHitbox = null;
          let resizingHitbox = null;
          let draggingSpriteOffset = null;
          let mouseButton = null;
          let debugMouseX = 0;
          let debugMouseY = 0;
          let isHKey = false;
          let isSKey = false;
        
          let koDisplayTime = 0;
          let gameOver = false;
        
          // Get player selections from sessionStorage, providing default empty array/object if null
          const selectedFighters = JSON.parse(sessionStorage.getItem("fighters") || "[]");
          const playerControls = JSON.parse(sessionStorage.getItem("controls") || "{}");
          const playerKeyMap = JSON.parse(sessionStorage.getItem("playerKeyMap") || "{}");


          // Determine playerAmount based on the number of selected fighters
          const playerAmount = selectedFighters.length;
        
          function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
          }
          window.addEventListener("resize", resizeCanvas);
          resizeCanvas();
        
          const bgPaths = [
            "Assets/Background1/Battleground1.png",
            "Assets/Background2/Battleground2.png",
            "Assets/Background3/Battleground1.png", // Corrected to use existing assets
            "Assets/Background4/Battleground4.png",
            "Assets/Background5/Battleground5.png",
            "Assets/Background6/Battleground6.png",
            "Assets/Background7/Battleground7.png",
            "Assets/Background8/Battleground8.png"
          ];
          const bgImage = new Image();
          bgImage.src = bgPaths[Math.floor(Math.random() * bgPaths.length)];
        
          const healthImg = new Image(); healthImg.src = "Assets/HealthBar.png";
          const staminaImg = new Image(); staminaImg.src = "Assets/StaminaBar.png";
        
          const animations = {
            Assasin: {
              Idle:{frameCount:4, rowOffset:0}, Run:{frameCount:8, rowOffset:0},
              Jump:{frameCount:2, rowOffset:0}, Fall:{frameCount:2, rowOffset:0},
              Attack1:{frameCount:4, rowOffset:0}, Attack2:{frameCount:4, rowOffset:0},
              TakeHit:{frameCount:3, rowOffset:0}, Death:{frameCount:7, rowOffset:0}
            },
            Wu: {
              Idle:{frameCount:8, rowOffset:0}, Run:{frameCount:8, rowOffset:0},
              Jump:{frameCount:2, rowOffset:0}, Fall:{frameCount:2, rowOffset:0},
              Attack1:{frameCount:6, rowOffset:0}, Attack2:{frameCount:6, rowOffset:0},
              TakeHit:{frameCount:4, rowOffset:0}, Death:{frameCount:6, rowOffset:0}
            },
            Darkrai: { // Corrected to match characterSprites name
              Idle:{frameCount:9, rowOffset:0 * 80}, Run:{frameCount:6, rowOffset:1 * 80},
              Attack1:{frameCount:12, rowOffset:2 * 80}, TakeHit:{frameCount:5, rowOffset:3 * 80},
              Jump:{frameCount:1, rowOffset:4 * 80}, // Removed specificFrame
              Fall:{frameCount:1, rowOffset:4 * 80}, // Removed specificFrame
              Death:{frameCount:24, rowOffset:4 * 80}
            },
            Reaper: {
                Idle: {frameCount: 8, rowOffset: 0 * 80},
                Run: {frameCount: 8, rowOffset: 0 * 80},
                Jump: {frameCount: 8, rowOffset: 0 * 80},
                Fall: {frameCount: 8, rowOffset: 0 * 80},
                Attack1: {frameCount: 8, rowOffset: 1 * 80},
                Attack2: {frameCount: 8, rowOffset: 1 * 80},
                TakeHit: {frameCount: 2, rowOffset: 2 * 80},
                Death: {frameCount: 12, rowOffset: 3 * 80}
            },
            // Tarzan animations
            Tarzan: {
                Idle: {frameCount: 10, rowOffset: 0, speed: 100, loop: true},
                Run: {frameCount: 8, rowOffset: 0, speed: 70, loop: true},
                Jump: {frameCount: 3, rowOffset: 0, speed: 100, loop: false}, // Frames 0,1 for jump up, 2 for mid-air
                Fall: {frameCount: 2, rowOffset: 0, speed: 100, loop: false}, // Frames 0,1 for falling (assuming they follow jump frames)
                Attack1: {frameCount: 7, rowOffset: 0, speed: 80, loop: false},
                Attack2: {frameCount: 6, rowOffset: 0, speed: 80, loop: false},
                TakeHit: {frameCount: 3, rowOffset: 0, speed: 100, loop: false}, // Take Hit
                Death: {frameCount: 11, rowOffset: 0, speed: 100, loop: false}
            },
            // Knight animations (UPDATED)
            Knight: {
                Idle: {frameCount: 7, rowOffset: 0, speed: 100, loop: true},
                Run: {frameCount: 8, rowOffset: 0, speed: 70, loop: true},
                Jump: {frameCount: 1, rowOffset: 0, specificFrame: 1, loop: false}, // rowOffset is in pixels
                Fall: {frameCount: 1, rowOffset: 0, specificFrame: 3, loop: false}, // rowOffset is in pixels, specific frame 3
                Attack1: {frameCount: 6, rowOffset: 0, speed: 80, loop: false},
                Attack2: {frameCount: 6, rowOffset: 0, speed: 80, loop: false},
                Defend: {frameCount: 1, rowOffset: 0, specificFrame: 1, loop: false},
                TakeHit: {frameCount: 4, rowOffset: 0, speed: 100, loop: false},
                Death: {frameCount: 12, rowOffset: 0, speed: 100, loop: false}
            }
          };
        
          const stats = {
            "Assasin": {
              "frameWidth": 200, "frameHeight": 200,
              "at1": 5, "at2": 10, "hp": 100, "stam": 50, "spd": 7, "lives": 5,
              "attackBoxes": [
                { "attack": 2, "x": 138.5, "y": -172, "rx": 235, "ry": 215 },
                { "attack": 1, "x": 150.5, "y": -141, "rx": 232, "ry": 130 }
              ],
              "at1SL": 1, "at2SL": 2,
              "hitBox": { xRel: -50, yRel: -200, w: 100, h: 200 },
              "spriteDrawOffset": { xRel: -100.55555555555557, yRel: -130 },
              "healthregen": 0.05,
              "staminaregen": 0.1,
              "supurpower": false,
              "attackdelay": 1500
            },
            "Wu": {
              "frameWidth": 200, "frameHeight": 200,
              "at1": 5, "at2": 10, "hp": 120, "stam": 50, "spd": 5, "lives": 5,
              "attackBoxes": [
                { "attack": 2, "x": 176.83333333333292, "y": -136, "rx": 249, "ry": 113 },
                { "attack": 1, "x": 98.83333333333292, "y": -163, "rx": 301, "ry": 151 }
              ],
              "at1SL": 2, "at2SL": 3,
              "hitBox": { xRel: -50, yRel: -200, w: 100, h: 200 },
              "spriteDrawOffset": { xRel: -98.66666666666669, yRel: -122 },
              "healthregen": 0.05,
              "staminaregen": 0.1,
              "supurpower": false,
              "attackdelay": 1000
            },
            "Darkrai": { // Corrected to match characterSprites name
              "frameWidth": 80, "frameHeight": 80,
              "at1": 10, "at2": 15, "hp": 75, "stam": 30, "spd": 7, "lives": 5,
              "attackBoxes": [
                { "attack": 1, "x": 15.249999999999886, "y": -108, "rx": 164.0000000000001, "ry": 147 }
              ],
              "at1SL": 2, "at2SL": 4,
              "hitBox": { xRel: -43.750000000000114, yRel: -138, w: 112.00000000000011, h: 137 },
              "spriteDrawOffset": { xRel: -39.72222222222225, yRel: -65 },
              "healthregen": 0.05,
              "staminaregen": 0.1,
              "supurpower": false,
              "attackdelay": 2000
            },
            "Reaper": {
                "frameWidth": 80, "frameHeight": 80,
                "at1": 10, "at2": 15, "hp": 160, "stam": 55, "spd": 4, "lives": 5,
                  "attackBoxes": [
              {
                "attack": 1,
                "x": 46.125,
                "y": -122,
                "rx": 138,
                "ry": 139
              }
            ],
                "at1SL": 2, "at2SL": 3,
              "hitBox": { xRel: -50, yRel: -260, w: 200, h: 240 },
                "spriteDrawOffset": { xRel: -30, yRel: -70 },
                "healthregen": 0.05,
                "staminaregen": 0.1,
                "supurpower": false,
                "attackdelay": 1000
            },
            // Tarzan stats - Updated with user's provided values (excluding worldX/Y)
            "Tarzan": {
                "frameWidth": 126, "frameHeight": 126,
                "at1": 8, "at2": 12, "hp": 110, "stam": 60, "spd": 6, "lives": 5,
                "attackBoxes": [
                    { "attack": 1, "x": 12.333333333333371, "y": -176, "rx": 229, "ry": 192 },
                    { "attack": 2, "x": 7.333333333333371, "y": -167, "rx": 252, "ry": 169 }
                ],
                "at1SL": 2, "at2SL": 3,
                "hitBox": { "xRel": -62.33333333333337, "yRel": -179, "w": 127.66666666666674, "h": 175 },
                "spriteDrawOffset": { "xRel": -69.85185185185183, "yRel": -82.66666666666667 },
                "healthregen": 0.05,
                "staminaregen": 0.1,
                "supurpower": true,
                "attackdelay": 800
            },
            // Knight stats - Updated with user's provided values (excluding worldX/Y)
            "Knight": {
                "frameWidth": 96, "frameHeight": 84,
                "at1": 12, "at2": 18, "hp": 150, "stam": 40, "spd": 4, "lives": 5,
                "attackBoxes": [
                    { "attack": 1, "x": 47.666666666666515, "y": -103, "rx": 97, "ry": 107 },
                    { "attack": 2, "x": 24.666666666666515, "y": -119, "rx": 163, "ry": 69 }
                ],
                "at1SL": 3, "at2SL": 4,
                "hitBox": { "xRel": -37.33333333333326, "yRel": -152, "w": 90.66666666666674, "h": 149 },
                "spriteDrawOffset": { "xRel": -46.518518518518555, "yRel": -62.44444444444444 },
                "healthregen": 0.07,
                "staminaregen": 0.12,
                "supurpower": true,
                "attackdelay": 1200
            }
          };
        
          const preloadedImages = {};
        
          function loadSS(name, anim) {
            // Special handling for Darkrai and Reaper as they use single sprite sheets
            if (name === "Darkrai") {
                return `Assets/Darkdude.png`; // All Darkrai animations from this single file
            } else if (name === "Reaper") {
                return `Assets/Reaper.png`; // All Reaper animations from this single file
            }

            // For other characters, construct path based on character folder and animation file
            let characterAssetFolder = name;
            let animationFileName = anim;

            // Handle specific animation file names for characters that have separate files
            if (name === "Assasin" && anim === "TakeHit") {
                animationFileName = "Take-hit";
            } else if (name === "Wu" && anim === "TakeHit") {
                animationFileName = "Take Hit";
            } else if (name === "Tarzan" && anim === "Jump") {
                animationFileName = "Going Up";
            } else if (name === "Tarzan" && anim === "Fall") {
                animationFileName = "Going Down";
            } else if (name === "Tarzan" && anim === "TakeHit") {
                animationFileName = "Take Hit";
            } else if (name === "Knight") { // Knight has specific file names for all its animations
                if (anim === "Attack1") animationFileName = "ATTACK 1";
                else if (anim === "Attack2") animationFileName = "ATTACK 3";
                else if (anim === "TakeHit") animationFileName = "HURT";
                else if (anim === "Idle") animationFileName = "IDLE";
                else if (anim === "Run") animationFileName = "RUN";
                else if (anim === "Jump") animationFileName = "JUMP";
                else if (anim === "Fall") animationFileName = "JUMP"; // Knight uses JUMP for Fall
                else if (anim === "Defend") animationFileName = "DEFEND";
                else if (anim === "Death") animationFileName = "DEATH";
            }

            return `Assets/${characterAssetFolder}/${animationFileName}.png`;
          }
        
          class Player {
            constructor(name, x, displayName, playerIndex) { // Added playerIndex
              // Ensure 'name' matches a key in 'stats'
              if (!stats[name]) {
                  console.error(`Error: Character '${name}' not found in stats object. Falling back to Assasin.`);
                  name = "Assasin"; // Default to Assassin if character not found
              }
              this.originalStats = JSON.parse(JSON.stringify(stats[name]));
              Object.assign(this, stats[name]);
              this.targetsHitThisAttack = new Set();
              this.name = name;
              this.displayName = displayName; // Store displayName
              this.x = x;
              this.y = groundY;
              this.initialX = x;
              this.speedX = 0;
              this.health = this.hp;
              this.stamina = this.stam;
              this.maxHealth = this.hp;
              this.maxStamina = this.stam;
              this.lastActiveTime = performance.now();
              
              this.sht = this.frameWidth;
              this.svt = this.frameHeight;
              this.frameTimer = 0;
              this.frameDur = 100;
              this.curF = 0;
              this.curA = "Idle";
              this.dead = false;
              this.animDead = false;
              this.ss = null;
              this.currentAnimYOffset = 0;
              this.setA("Idle");
              this.fLeft = false;
              this.isJump = false;
              this.vy = 0;
              this.js = -10;
              this.gr = 0.4;
              this.lockedUntil = 0;
              this.lastDirection = 1;
              this.attackBoxes = JSON.parse(JSON.stringify(stats[name].attackBoxes || [])); 
              this.hitFlag = false;
              this.attackCooldownUntil = 0;
              this.pendingHurtAnim = null;
              this.isRespawning = false;
              this.respawnTime = 0;
        
              this.healthregen = this.healthregen;
              this.staminaregen = this.staminaregen;
              this.supurpower = false;
              this.attackdelay = this.attackdelay;

              this.isSuperMode = false;
              this.superModeToggleCooldown = 0;
              this.superModeDeactivationTime = 0;

              this.isDoubleSpeed = false;
              this.doubleSpeedEndTime = 0;

              this.jumpsUsedInAir = 0;

              // Tarzan specific properties
              this.isDashing = false;
              this.dashEndTime = 0;

              // Knight specific properties
              this.isDefending = false;
              this.defendTime = 0;
              this.defendDuration = 10000; // 10 seconds
              this.originalSpd = this.spd;
              this.originalHealthRegen = this.healthregen;
              this.originalStaminaRegen = this.staminaregen;

              // Player color for debug mode
              this.debugColor = playerKeyMap[`P${playerIndex + 1}`]?.color || "red";
            }
        
            setA(anim, lock = false) {
              if (this.curA === anim || (this.dead && anim !== "Death")) return;
              
              let animData = animations[this.name][anim];
              if (!animData) {
                this.curA = "Idle";
                animData = animations[this.name]["Idle"];
              } else {
                this.curA = anim;
              }
        
              const imageKey = `${this.name}_${this.curA}`;
              this.ss = preloadedImages[imageKey];
              
              if (!this.ss) { // Fallback if image not preloaded (shouldn't happen with Promise.all)
                  console.warn(`Image for ${imageKey} not found in preloadedImages.`);
                  return; // Prevent drawImage error
              }

              this.frameCount = animData.frameCount;
              this.currentAnimYOffset = animData.rowOffset || 0; // This is for Y offset (rows)
              
              this.curF = animData.specificFrame !== undefined ? animData.specificFrame : 0; // This sets initial frame
              
              this.frameTimer = 0;
              this.animDead = anim === "Death";
              this.lockedUntil = lock ? performance.now() + this.frameCount * this.frameDur : 0;
            }
        
            tryAtk(type) {
              const now = performance.now();
              let actualAttackType = type;
        
              if ((this.name === "Darkrai" || this.name === "Reaper") && type === "Attack2") { // Corrected Darkrai casing
                actualAttackType = "Attack1";
              }
        
              if (this.curA === actualAttackType || this.lockedUntil > now || now < this.attackCooldownUntil) return;
              this.targetsHitThisAttack.clear();
        
              const cost = actualAttackType === "Attack1" ? this.at1SL : this.at2SL;
              if (this.stamina >= cost) {
                this.stamina -= cost;
                this.hasHitDuringCurrentAttack = false;
                this.setA(actualAttackType, true);
                this.attackCooldownUntil = now + this.attackdelay;

                // Tarzan Superpower: Dash and double damage
                if (this.name === "Tarzan" && type === "Attack2" && this.speedX !== 0) {
                    this.isDashing = true;
                    this.dashEndTime = now + 500; // Dash for 0.5 seconds
                    this.spd = this.originalStats.spd * 4; // 4x speed burst
                    floatingTexts.push(new FloatingText("DASH ATTACK!", this.x, this.y - 100, "orange"));
                }
              }
            }

            // Knight Shield ability activation
            tryDefend() {
                const now = performance.now();
                const cost = this.maxStamina * 0.1; // 10% stamina cost
                if (this.name === "Knight" && this.stamina >= cost && !this.isDefending) {
                    this.stamina -= cost;
                    this.isDefending = true;
                    this.defendTime = now;
                    this.setA("Defend", true); // Set to Defend animation
                    this.spd = this.originalStats.spd * 0.25; // 25% speed
                    this.healthregen = this.originalStats.healthregen * 2; // Double healing
                    this.staminaregen = this.originalStats.staminaregen * 2; // Double stamina regen
                    // No floating text for shield activation to reduce clutter
                }
            }
        
            jump() {
                if (this.dead || this.jumpsUsedInAir >= 2) return;
        
                if (this.y === groundY) {
                    this.jumpsUsedInAir = 1;
                } else {
                    if (this.jumpsUsedInAir === 1) {
                        this.jumpsUsedInAir = 2;
                    } else {
                        return;
                    }
                }
                this.isJump = true;
                this.vy = this.js;
                this.setA("Jump", true);
            }

            updateAttackBoxes() {
                for (const box of this.attackBoxes) {
                    box.worldX = this.x + (this.fLeft ? -box.x : box.x);
                    box.worldY = this.y + box.y;
                }
            }
        
            update(dt) {
              const now = performance.now();
        
              this.updateAttackBoxes();
              if (this.isRespawning && now >= this.respawnTime) {
                this.x = this.initialX;
                this.y = groundY;
                this.health = this.maxHealth;
                this.stamina = this.maxStamina;
                this.isRespawning = false;
                this.dead = false;
                this.setA("Idle");
              }

              // Tarzan dash deactivation
              if (this.name === "Tarzan" && this.isDashing && now >= this.dashEndTime) {
                  this.isDashing = false;
                  this.spd = this.originalStats.spd; // Reset speed
              }

              // Knight shield deactivation
              if (this.name === "Knight" && this.isDefending && (now - this.defendTime) >= this.defendDuration) {
                  this.isDefending = false;
                  this.spd = this.originalStats.spd; // Reset speed
                  this.healthregen = this.originalStats.healthregen; // Reset healing
                  this.staminaregen = this.originalStats.staminaregen; // Reset stamina regen
                  floatingTexts.push(new FloatingText("SHIELD OFF", this.x, this.y - 100, "grey"));
              }

              if (this.name === "Darkrai" && this.isSuperMode && now >= this.superModeDeactivationTime) { // Corrected Darkrai casing
                  this.isSuperMode = false;
                  this.at1 = this.originalStats.at1;
                  this.at2 = this.originalStats.at2;
                  this.hp = this.originalStats.hp;
                  this.health = Math.min(this.health, this.hp);
                  this.maxHealth = this.hp;
                  this.spd = this.originalStats.spd;
                  this.stam = this.originalStats.stam;
                  this.maxStamina = this.stam;
                  this.hitBox.xRel = this.originalStats.hitBox.xRel;
                  this.hitBox.yRel = this.originalStats.hitBox.yRel;
                  this.hitBox.w = this.originalStats.hitBox.w;
                  this.hitBox.h = this.originalStats.hitBox.h;
                  this.attackBoxes.forEach((box, index) => { // Fixed index not defined error
                      box.x = this.originalStats.attackBoxes[index].x;
                      box.y = this.originalStats.attackBoxes[index].y;
                      box.rx = player.originalStats.attackBoxes[index].rx;
                      box.ry = player.originalStats.attackBoxes[index].ry;
                  });
                  floatingTexts.push(new FloatingText("MODE OFF", this.x, this.y - 100, "grey"));
              }

              if (this.name === "Reaper" && this.isDoubleSpeed && now >= this.doubleSpeedEndTime) {
                  this.isDoubleSpeed = false;
                  this.spd = this.originalStats.spd;
                  floatingTexts.push(new FloatingText("SPEED OFF", this.x, this.y - 100, "grey"));
              }
        
              if (pauseGame || this.dead || this.isRespawning) {
                  if (this.animDead && this.curA === "Death") {
                      this.frameTimer += dt;
                      if (this.frameTimer >= this.frameDur) {
                          this.frameTimer = 0;
                          if (this.curF < this.frameCount - 1) {
                              this.curF++;
                          } else {
                              this.animDead = false;
                              if (this.lives <= 0) {
                                  this.curF = this.frameCount - 1;
                              }
                          }
                      }
                  }
                  return;
              }
        
              if (this.lockedUntil > now) {
                  // Animation is locked, continue current animation
              } else if (this.pendingHurtAnim) { // Attacked takes highest priority
                  this.setA(this.pendingHurtAnim.type, true);
                  this.pendingHurtAnim = null;
              } else if (this.isDefending) {
                  if (this.speedX !== 0) { // If moving while defending
                      this.setA("Run"); // Play run animation
                  } else { // If stationary while defending
                      this.setA("Defend"); // Play specific defend frame
                  }
              } else if (this.y < groundY) { // Player is in the air (jumping or falling)
                  if (this.vy < 0) { // Going up
                      if (this.curA !== "Jump") {
                          this.setA("Jump");
                      }
                  } else { // Going down or mid-air (vy >= 0)
                      if (this.curA !== "Fall") {
                          this.setA("Fall");
                      }
                  }
              } else if (this.speedX) {
                this.setA("Run");
              } else {
                this.setA("Idle");
              }
        
              this.frameTimer += dt;
        
              const animData = animations[this.name][this.curA];
              const oneShot = ["Attack1", "Attack2", "TakeHit", "Death"]; 
              if (animData && animData.specificFrame !== undefined) {
                  // If it's a specific frame animation, it's treated as one-shot for frame progression
                  if (!oneShot.includes(this.curA)) oneShot.push(this.curA);
              }
        
              if (oneShot.includes(this.curA)) {
                if (this.frameTimer >= this.frameDur) {
                  this.frameTimer = 0;
                  // For specificFrame animations, we don't increment curF, it stays at specificFrame.
                  // For other one-shot animations, increment until last frame.
                  if (animData && animData.specificFrame !== undefined) {
                      // Do nothing, curF is fixed by setA
                  } else if (this.curF < this.frameCount - 1) {
                    this.curF++;
                  } else {
                    if (!this.dead) {
                        this.setA("Idle"); // Return to idle after one-shot animation
                    }
                  }
                }
              } else if (animData && animData.loop) { // Standard looping animations
                  if (this.frameTimer >= this.frameDur) {
                      this.frameTimer = 0;
                      this.curF = (this.curF + 1) % this.frameCount;
                  }
              } else if (this.frameTimer >= this.frameDur) { // Non-looping, non-one-shot (e.g., Run)
                this.frameTimer = 0;
                this.curF = (this.curF + 1) % this.frameCount;
              }
        
              this.x += this.speedX;
              this.y += this.vy;
              this.vy += this.gr;
        
              if (this.y >= groundY) {
                this.y = groundY;
                this.isJump = false;
                this.vy = 0;
                this.jumpsUsedInAir = 0;
              }
        
              if (this.speedX !== 0 || this.lockedUntil > now) {
                this.lastActiveTime = now;
              }
        
              // Apply regeneration based on current regeneration rates (modified by shield)
              if (now - this.lastActiveTime > 2000) {
                if (this.stamina < this.maxStamina) {
                  this.stamina += this.maxStamina * (dt / 1000) * this.staminaregen;
                  this.stamina = Math.min(this.stamina, this.maxStamina);
                }
                if (this.health < this.maxHealth) {
                  this.health += this.maxHealth * (dt / 1000) * this.healthregen;
                  this.health = Math.min(this.health, this.maxHealth);
                }
              }
        
              if (this.speedX < 0) this.lastDirection = -1;
              else if (this.speedX > 0) this.lastDirection = 1;
              this.fLeft = this.lastDirection === -1;
        
              if (this.pendingHurtAnim && now >= this.pendingHurtAnim.startTime) {
                  this.setA(this.pendingHurtAnim.type, true);
                  this.pendingHurtAnim = null;
              }
            }
        
            draw(camX) {
              if (!this.ss || !this.ss.complete) {
                return;
              }
        
              const sx = this.curF * this.sht;
              const sy = this.currentAnimYOffset;
        
              let currentDrawScale = SCALE;
              if (this.name === "Darkrai" && this.isSuperMode) { // Corrected Darkrai casing
                  currentDrawScale *= 2;
              }
        
              const playerWorldXOnCanvas = this.x - camX;
        
              ctx.save();
        
              ctx.translate(playerWorldXOnCanvas, this.y);
        
              if (this.fLeft) {
                  ctx.scale(-1, 1);
              }
        
              ctx.drawImage(
                  this.ss, sx, sy, this.sht, this.svt,
                  this.spriteDrawOffset.xRel * currentDrawScale,
                  this.spriteDrawOffset.yRel * currentDrawScale,
                  this.sht * currentDrawScale,
                  this.svt * currentDrawScale
              );
        
              ctx.restore();

              // Knight Shield visual - removed translucent blue rectangle
              // if (this.name === "Knight" && this.isDefending) {
              //     ctx.save();
              //     ctx.globalAlpha = 0.5;
              //     ctx.fillStyle = "lightblue";
              //     const hbX = this.x + (this.fLeft ? -(this.hitBox.xRel + this.hitBox.w) : this.hitBox.xRel) - camX;
              //     const hbY = this.y + this.hitBox.yRel;
              //     const hbW = this.hitBox.w;
              //     const hbH = this.hitBox.h;
              //     ctx.fillRect(hbX, hbY, hbW, hbH);
              //     ctx.restore();
              // }
              
              // Draw player name above the character (moved to be above hitbox)
              ctx.save();
              ctx.font = "24px FightFont, sans-serif";
              ctx.textAlign = "center";
              ctx.fillStyle = "white";
              ctx.strokeStyle = "black";
              ctx.lineWidth = 3;
              // Position name above the hitbox, adjusted for sprite offset
              const nameY = this.y + this.hitBox.yRel - 20; // 20 pixels above the top of the hitbox
              ctx.strokeText(this.displayName.toUpperCase(), playerWorldXOnCanvas, nameY);
              ctx.fillText(this.displayName.toUpperCase(), playerWorldXOnCanvas, nameY);
              ctx.restore();


              if (debugMode) {
                const hbX = this.x + (this.fLeft ? -(this.hitBox.xRel + this.hitBox.w) : this.hitBox.xRel) - camX;
                const hbY = this.y + player.hitBox.yRel; // Fixed 'p' to 'player'
                const hbW = this.hitBox.w;
                const hbH = this.hitBox.h;
        
                ctx.fillStyle = "rgba(255, 0, 0, 0.3)";
                ctx.fillRect(hbX, hbY, hbW, hbH);
                ctx.lineWidth = 3;
                // Use player-specific color for hitbox outline
                ctx.strokeStyle = this.debugColor; // Use the stored debug color
                ctx.strokeRect(hbX, hbY, hbW, hbH);
        
                ctx.fillStyle = "blue";
                ctx.beginPath();
                ctx.arc(this.x - camX, this.y, 5, 0, Math.PI * 2);
                ctx.fill();
        
                for (const box of this.attackBoxes) {
                  const attackBoxCanvasX = this.x + (this.fLeft ? -box.x : box.x) - camX;
                  const attackBoxCanvasY = this.y + box.y;

                  ctx.beginPath();
                  ctx.ellipse(attackBoxCanvasX, attackBoxCanvasY, box.rx, box.ry, 0, 0, 2 * Math.PI);
                  ctx.fillStyle = "rgba(100,200,255,0.3)";
                  ctx.fill();
                  ctx.strokeStyle = "white";
                  ctx.stroke();
                }
              }
            }
          }
          ctx.imageSmoothingEnabled = false;
        
          class Vector2 {
            constructor(x, y) { this.x = x; this.y = y; }
            add(other) { return new Vector2(this.x + other.x, this.y + other.y); }
            subtract(other) { return new Vector2(this.x - other.x, this.y - other.y); }
            scale(scalar) { return new Vector2(this.x * scalar, this.y * scalar); }
            dot(other) { return this.x * other.x + other.y * this.y; }
            magnitude() { return Math.sqrt(this.x * this.x + this.y * this.y); }
            normalize() {
                const mag = this.magnitude();
                if (mag === 0) return new Vector2(0, 0);
                return new Vector2(this.x / mag, this.y / mag);
            }
            perp() { return new Vector2(-this.y, this.x); }
            rotate(angle) {
                const cos = Math.cos(angle);
                const sin = Math.sin(angle);
                return new Vector2( this.x * cos - this.y * sin, this.x * sin + this.y * cos );
            }
          }
        
          function getRotatedRectVertices(rectX, rectY, rectWidth, rectHeight, rectAngle) {
            const halfW = rectWidth / 2;
            const halfH = rectHeight / 2;
            const center = new Vector2(rectX, rectY);
            const vertices = [
                new Vector2(-halfW, -halfH), new Vector2( halfW, -halfH),
                new Vector2( halfW,  halfH), new Vector2(-halfW,  halfH)
            ];
            return vertices.map(v => v.rotate(rectAngle).add(center));
          }
        
          function getRectAxes(rectVertices) {
            const axes = [];
            for (let i = 0; i < 4; i++) {
                const p1 = rectVertices[i];
                const p2 = rectVertices[(i + 1) % 4];
                const edge = p2.subtract(p1);
                axes.push(edge.perp().normalize());
            }
            return axes;
          }
        
          function getEllipseProjection(ellipsePos, ellipseHalfWidth, ellipseHalfHeight, ellipseAngle, axis) {
            const localAxis = axis.rotate(-ellipseAngle);
            const a = ellipseHalfWidth;
            const b = ellipseHalfHeight;
            const projectionRadius = Math.sqrt( (a * a * localAxis.x * localAxis.x) + (b * b * localAxis.y * localAxis.y) );
            const centerProjection = ellipsePos.dot(axis);
            return { min: centerProjection - projectionRadius, max: centerProjection + projectionRadius };
          }
        
          function getEllipseClosestPointAxis(ellipsePos, ellipseHalfWidth, ellipseHalfHeight, ellipseAngle, rectVertex) {
            const translatedVertex = rectVertex.subtract(ellipsePos);
            const localVertex = translatedVertex.rotate(-ellipseAngle);
        
            if (localVertex.x === 0 && localVertex.y === 0) return null;
        
            const angle = Math.atan2(localVertex.y, localVertex.x);
            const cosA = Math.cos(angle);
            const sinA = Math.sin(angle);
            const a = ellipseHalfWidth;
            const b = ellipseHalfHeight;
        
            const denominator = Math.sqrt((a * a * sinA * sinA) + (b * b * cosA * cosA));
            const xIntersect = (a * b * cosA) / denominator;
            const yIntersect = (a * b * sinA) / denominator;
            const closestPointOnLocalEllipse = new Vector2(xIntersect, yIntersect);
        
            const normalLocal = new Vector2( closestPointOnLocalEllipse.x / (a * a), closestPointOnLocalEllipse.y / (b * b) ).normalize();
            const normalGlobal = normalLocal.rotate(ellipseAngle);
            return normalGlobal;
          }
        
          function checkOverlap(proj1, proj2) {
            return Math.max(proj1.min, proj2.min) < Math.min(proj1.max, proj2.max);
          }
        
          function ellipseRectCollisionSAT(
            ellipseX, ellipseY, ellipseWidth, ellipseHeight, ellipseAngle,
            rectX, rectY, rectWidth, rectHeight, rectAngle
          ) {
            const ellipsePos = new Vector2(ellipseX, ellipseY);
            const ellipseHalfWidth = ellipseWidth / 2;
            const ellipseHalfHeight = ellipseHeight / 2;
        
            const rectVertices = getRotatedRectVertices(rectX, rectY, rectWidth, rectHeight, rectAngle);
            const axes = getRectAxes(rectVertices);
        
            axes.push(new Vector2(1, 0).rotate(ellipseAngle));
            axes.push(new Vector2(0, 1).rotate(ellipseAngle));
        
            for (const rectVertex of rectVertices) {
                const ellipseAxis = getEllipseClosestPointAxis(ellipsePos, ellipseHalfWidth, ellipseHalfHeight, ellipseAngle, rectVertex);
                if (ellipseAxis) {
                     axes.push(ellipseAxis);
                }
            }
        
            for (const axis of axes) {
                const ellipseProjection = getEllipseProjection(ellipsePos, ellipseHalfWidth, ellipseHalfHeight, ellipseAngle, axis);
                let minRectProj = Infinity;
                let maxRectProj = -Infinity;
                for (const vertex of rectVertices) { 
                    const proj = vertex.dot(axis);
                    minRectProj = Math.min(minRectProj, proj);
                    maxRectProj = Math.max(maxRectProj, proj);
                }
                const rectProjection = { min: minRectProj, max: maxRectProj };
        
                if (!checkOverlap(ellipseProjection, rectProjection)) {
                    return false;
                }
            }
            return true;
          }
        
          // Dynamically create players based on selectedFighters from sessionStorage
          const players = [];
          if (playerAmount > 0) {
              selectedFighters.forEach((fighter, index) => {
                  const xPos = canvas.width / (playerAmount + 1) * (index + 1);
                  players.push(new Player(fighter.character, xPos, fighter.displayName, index)); // Pass player index
              });
          }

          let activeDebugPlayer = null;
        
          const keysDown = {};
          const keysJustPressed = {};
        
          // Gamepad state
          let gamepads = [];
          const gamepad_button_map = {
              0: "gamepad_cross", // X button
              1: "gamepad_circle", // Circle button
              2: "gamepad_square", // Square button
              3: "gamepad_triangle", // Triangle button
              4: "gamepad_l1", // L1
              5: "gamepad_r1", // R1
              6: "gamepad_l2", // L2
              7: "gamepad_r2", // R2
              // Add more as needed
          };
          // Threshold for joystick input to be considered "pressed"
          const AXIS_THRESHOLD = 0.5;

          // Gamepad polling function
          function updateGamepads() {
              gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
              for (let i = 0; i < gamepads.length; i++) {
                  const gp = gamepads[i];
                  if (gp) {
                      const playerIdentifier = `P${gp.index + 1}`; // Assuming gamepad index maps to player index + 1
                      const playerControlScheme = playerControls[playerIdentifier];

                      if (playerControlScheme) {
                          // Handle buttons
                          for (let b = 0; b < gp.buttons.length; b++) {
                              const buttonName = gamepad_button_map[b];
                              // Check if this button is mapped to any action for the current player
                              if (buttonName && Object.values(playerControlScheme).includes(buttonName)) {
                                  if (gp.buttons[b].pressed) {
                                      if (!keysDown[buttonName]) {
                                          keysJustPressed[buttonName] = true;
                                      }
                                      keysDown[buttonName] = true;
                                  } else {
                                      delete keysDown[buttonName];
                                      delete keysJustPressed[buttonName]; // Clear just pressed on release
                                  }
                              }
                          }

                          // Handle axes (joysticks)
                          // Left Stick horizontal for moveLeft/moveRight
                          const leftStickX = gp.axes[0]; 

                          // Move Left
                          if (leftStickX < -AXIS_THRESHOLD) {
                              if (!keysDown[playerControlScheme.moveLeft]) {
                                  keysJustPressed[playerControlScheme.moveLeft] = true;
                              }
                              keysDown[playerControlScheme.moveLeft] = true;
                          } else {
                              delete keysDown[playerControlScheme.moveLeft];
                              delete keysJustPressed[playerControlScheme.moveLeft];
                          }

                          // Move Right
                          if (leftStickX > AXIS_THRESHOLD) {
                              if (!keysDown[playerControlScheme.moveRight]) {
                                  keysJustPressed[playerControlScheme.moveRight] = true;
                              }
                              keysDown[playerControlScheme.moveRight] = true;
                          } else {
                              delete keysDown[playerControlScheme.moveRight];
                              delete keysJustPressed[playerControlScheme.moveRight];
                          }
                      }
                  }
              }
          }

          window.addEventListener("keydown", e => {
            const k = e.key.toLowerCase(); // Convert to lowercase for consistent key mapping
            isHKey = (k === 'h');
            isSKey = (k === 's');
        
            if (!(k in keysDown)) {
                keysJustPressed[k] = true;
            }
            keysDown[k] = true;
        
            if (k === 'p') {
              pauseGame = !pauseGame;
              if (pauseGame) pausedFrame = ctx.getImageData(0, 0, canvas.width, canvas.height);
            }
            // Removed debug toggle for 'b' key
          });
        
          window.addEventListener("keyup", e => {
            const k = e.key.toLowerCase(); // Convert to lowercase for consistent key mapping
            isHKey = (k !== 'h') ? isHKey : false;
            isSKey = (k !== 's') ? isSKey : false;
        
            delete keysDown[k];
            delete keysJustPressed[k];
          });
        
          canvas.addEventListener("mousemove", e => {
            const rect = canvas.getBoundingClientRect();
            debugMouseX = e.clientX - rect.left;
            debugMouseY = e.clientY - rect.top;
        
            const worldMouseX = debugMouseX + cameraX;
            const worldMouseY = debugMouseY;
        
            if (debugMode) {
              if (draggingEllipse) {
                const { player, box } = draggingEllipse;
                box.x = (player.fLeft ? -(worldMouseX - player.x) : (worldMouseX - player.x));
                box.y = worldMouseY - player.y;
              } else if (resizingEllipse) {
                const { player, box } = resizingEllipse;
                const cx = player.x + (player.fLeft ? -box.x : box.x);
                const cy = player.y + box.y;
                box.rx = Math.abs((worldMouseX) - cx);
                box.ry = Math.abs(worldMouseY - cy);
              } else if (draggingHitbox) {
                const { player } = draggingHitbox;
                player.hitBox.xRel = (player.fLeft ? -(worldMouseX - player.x) : (worldMouseX - player.x));
                player.hitBox.yRel = worldMouseY - player.y;
              } else if (resizingHitbox) {
                const { player } = resizingHitbox;
                player.hitBox.w = Math.max(1, worldMouseX - (player.x + player.hitBox.xRel));
                player.hitBox.h = Math.max(1, worldMouseY - (player.y + player.hitBox.yRel));
              } else if (draggingSpriteOffset && activeDebugPlayer) { // Only drag sprite offset for active player
                const { player } = draggingSpriteOffset;
                player.spriteDrawOffset.xRel = (player.fLeft ? -(worldMouseX - player.x) : (worldMouseX - player.x)) / SCALE;
                player.spriteDrawOffset.yRel = (worldMouseY - player.y) / SCALE;
              }
            }
          });
        
          canvas.addEventListener("mousedown", e => {
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;
            debugMouseX = mx;
            debugMouseY = my;
            mouseButton = e.button;
        
            if (debugMode) {
              // Copy Debug Info button
              if (mx > 10 && mx < 230 && my > canvas.height - 50 && my < canvas.height - 10) {
                const updatedStats = {};
                players.forEach(player => {
                  updatedStats[player.name] = {
                    ...stats[player.name],
                    attackBoxes: player.attackBoxes.map(b => ({ ...b })),
                    hitBox: { ...player.hitBox },
                    spriteDrawOffset: { ...player.spriteDrawOffset }
                  };
                });
                const js = `const stats = ${JSON.stringify(updatedStats, null, 2)};`;
                const tempTextArea = document.createElement("textarea");
                tempTextArea.value = js;
                document.body.appendChild(tempTextArea);
                tempTextArea.select();
                try {
                    document.execCommand('copy');
                } catch (err) {
                }
                document.body.removeChild(tempTextArea);
                return;
              }
        
              // Check for dragging/resizing hitboxes or ellipses for ANY player
              let handled = false;

              for (const player of players) {
                  const hbX = player.x + (player.fLeft ? -(player.hitBox.xRel + player.hitBox.w) : player.hitBox.xRel) - cameraX;
                  const hbY = player.y + player.hitBox.yRel;
          
                  // Check for hitbox interaction
                  if (mx > hbX && mx < hbX + player.hitBox.w &&
                      my > hbY && my < hbY + player.hitBox.h) {
                      if (mouseButton === 0 && isHKey) { // Drag hitbox with H key
                          draggingHitbox = { player };
                          activeDebugPlayer = player; // Set active player for sprite offset
                          handled = true;
                          break;
                      } else if (mouseButton === 2 && isHKey) { // Resize hitbox with H key
                          resizingHitbox = { player };
                          activeDebugPlayer = player; // Set active player for sprite offset
                          handled = true;
                          break;
                      }
                  }

                  // Check for attack box interaction (no H or S key needed)
                  for (const box of player.attackBoxes) {
                    const bx = player.x + (player.fLeft ? -box.x : box.x) - cameraX;
                    const by = player.y + box.y;
                    const dx = mx - bx;
                    const dy = my - by;
                    if ((dx * dx) / (box.rx * box.rx) + (dy * dy) / (box.ry * box.ry) <= 1) {
                      if (mouseButton === 0) { // Drag ellipse
                          draggingEllipse = { player, box };
                          activeDebugPlayer = player; // Set active player for sprite offset
                          handled = true;
                          break;
                      } else if (mouseButton === 2) { // Resize ellipse
                          resizingEllipse = { player, box };
                          activeDebugPlayer = player; // Set active player for sprite offset
                          handled = true;
                          break;
                      }
                    }
                  }
                  if (handled) break;
              }

              // If no hitbox or attack box was clicked, check for sprite offset drag
              if (!handled && isSKey) {
                  for (const player of players) {
                      const spriteDrawX = player.x + (player.fLeft ? -(player.sht * SCALE) + (player.spriteDrawOffset.xRel * SCALE) : (player.spriteDrawOffset.xRel * SCALE)) - cameraX;
                      const spriteDrawY = player.y + (player.spriteDrawOffset.yRel * SCALE);
            
                      if (mx > spriteDrawX && mx < spriteDrawX + (player.sht * SCALE) &&
                          my > spriteDrawY && my < spriteDrawY + (player.svt * SCALE)) {
                          if (mouseButton === 0) {
                              draggingSpriteOffset = { player };
                              activeDebugPlayer = player; // Set active player
                              handled = true;
                              break;
                          }
                      }
                  }
              }

              // If nothing was dragged/resized, and no specific key was held, then select the player if clicked
              if (!handled) {
                  activeDebugPlayer = null; // Clear active player if no specific debug element was clicked
                  for (const player of players) {
                      const spriteDrawX = player.x + (player.fLeft ? -(player.sht * SCALE) + (player.spriteDrawOffset.xRel * SCALE) : (player.spriteDrawOffset.xRel * SCALE)) - cameraX;
                      const spriteDrawY = player.y + (player.spriteDrawOffset.yRel * SCALE);
            
                      if (mx > spriteDrawX && mx < spriteDrawX + (player.sht * SCALE) &&
                          my > spriteDrawY && my < my + (player.svt * SCALE)) { 
                          activeDebugPlayer = player;
                          break;
                      }
                  }
              }
            }
          });
        
          canvas.addEventListener("mouseup", () => {
            draggingEllipse = null;
            resizingEllipse = null;
            draggingHitbox = null;
            resizingHitbox = null;
            draggingSpriteOffset = null;
            mouseButton = null;
          });
          canvas.addEventListener("contextmenu", e => e.preventDefault());
        
          let lst = 0;
          let countdownTime = 4;
          let countdownStarted = false;
        
          let assetsLoaded = false;
          const imagesToLoadPromises = [];
        
          imagesToLoadPromises.push(new Promise(resolve => {
            bgImage.onload = () => { resolve(); };
            bgImage.onerror = () => { resolve(); };
          }));
        
          imagesToLoadPromises.push(new Promise(resolve => {
            healthImg.onload = () => { resolve(); };
            healthImg.onerror = () => { resolve(); };
          }));
          imagesToLoadPromises.push(new Promise(resolve => {
            staminaImg.onload = () => { resolve(); };
            staminaImg.onerror = () => { resolve(); };
          }));
        
          // Load images only for the characters that will be present in the game
          const charactersToLoad = new Set(selectedFighters.map(f => f.character));
          for (const charName in animations) {
            if (charactersToLoad.has(charName)) {
              for (const animName in animations[charName]) {
                  const imageKey = `${charName}_${animName}`;
                  const img = new Image();
                  img.src = loadSS(charName, animName);
                  preloadedImages[imageKey] = img;
            
                  imagesToLoadPromises.push(new Promise(resolve => {
                    img.onload = () => { resolve(); };
                    img.onerror = () => { resolve(); };
                  }));
              }
            }
          }
        
          Promise.all(imagesToLoadPromises).then(() => {
              assetsLoaded = true;
              // Start the loop after assets are loaded
              requestAnimationFrame(loop);
          }).catch(error => {
              // Log error but still try to run the loop with loaded assets
              console.error("Error loading assets:", error);
              assetsLoaded = true; // Still try to proceed
              requestAnimationFrame(loop);
          });
        
        function drawCountdown() {
          if (bgImage.complete) {
            let currentDrawWidth = BG_TILE_WIDTH;
            let currentDrawHeight = BG_TILE_HEIGHT;
        
            if (bgImage.src.includes("Background5") ||
                bgImage.src.includes("Background6") ||
                bgImage.src.includes("Background7") ||
                bgImage.src.includes("Background8")
               ) {
                currentDrawWidth = canvas.width;
                currentDrawHeight = canvas.height;
            }
        
            for (
              let x = Math.floor(cameraX / currentDrawWidth) * currentDrawWidth;
              x < cameraX + canvas.width;
              x += currentDrawWidth
            ) {
              ctx.drawImage(bgImage, x - cameraX, 0, currentDrawWidth, currentDrawHeight);
            }
          }
        
          const text = countdownTime === 1 ? "FIGHT!" : `${countdownTime - 1}`;
          ctx.font = "300px FightFont, sans-serif";
          ctx.textAlign = "center";
          ctx.lineWidth = 6;
          ctx.strokeStyle = "#ff69b4";
          ctx.fillStyle = "#ffe600";
          ctx.strokeText(text, canvas.width / 2, canvas.height / 2);
          ctx.fillText(text, canvas.width / 2, canvas.height / 2);
        }
        
        class FloatingText {
          constructor(text, x, y, color = "white", duration = 1000) {
            this.text = text;
            this.x = x;
            this.y = y;
            this.color = color;
            this.startTime = performance.now();
            this.duration = duration;
            this.alpha = 1;
            this.dy = -0.5;
          }
        
          draw(ctx) {
            const elapsed = performance.now() - this.startTime;
            if (elapsed > this.duration) return false;
        
            this.y += this.dy;
            this.alpha = 1 - elapsed / this.duration;
        
            ctx.save();
            ctx.globalAlpha = this.alpha;
            ctx.font = "64px FightFont, sans-serif";
            ctx.textAlign = "center";
            ctx.lineWidth = 4;
            ctx.strokeStyle = "black";
            ctx.fillStyle = this.color;
            ctx.strokeText(this.text, this.x - cameraX, this.y);
            ctx.fillText(this.text, this.x - cameraX, this.y);
            ctx.restore();
            return true;
          }
        }

        function checkStaminaForSpecial(player) {
          return player.stamina / player.maxStamina >= 0.9;
        }
        
        function loop(ts = 0) {
          const dt = ts - lst;
          lst = ts;
        
          // Update gamepad state at the beginning of each loop
          updateGamepads();

          if (!countdownStarted) {
            countdownStarted = true;
            const countdownInterval = setInterval(() => {
              countdownTime--;
              if (countdownTime === 0) clearInterval(countdownInterval);
            }, 1000);
          }
        
          const playersWithLives = players.filter(p => p.lives > 0);
          const alivePlayersCount = playersWithLives.length;
        
          if (alivePlayersCount <= 1 && !gameOver && countdownTime <= 0) { // Check countdown before ending game
            gameOver = true;
            koDisplayTime = performance.now();
          }
          
          if (gameOver) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (bgImage.complete) {
                let currentDrawWidth = BG_TILE_WIDTH;
                let currentDrawHeight = BG_TILE_HEIGHT;
        
                if (bgImage.src.includes("Background5") ||
                    bgImage.src.includes("Background6") ||
                    bgImage.src.includes("Background7") ||
                    bgImage.src.includes("Background8")
                   ) {
                    currentDrawWidth = canvas.width;
                    currentDrawHeight = canvas.height;
                }
        
                for (let x = Math.floor(cameraX / currentDrawWidth) * currentDrawWidth; x < cameraX + canvas.width; x += currentDrawWidth)
                  ctx.drawImage(bgImage, x - cameraX, 0, currentDrawWidth, currentDrawHeight);
            }
        
            players.forEach(player => player.draw(cameraX));
            
            // Draw bars dynamically based on actual player count
            players.forEach((player, index) => {
                const isRightAligned = index % 2 !== 0; // Alternates left/right alignment
                const yOffset = Math.floor(index / 2) * 220 + 40; // Adjusts y position for multiple pairs
                drawBars(40, yOffset, player, isRightAligned);
            });
        
            if (performance.now() - koDisplayTime >= 0) {
                ctx.font = "250px FightFont, sans-serif";
                ctx.textAlign = "center";
                ctx.strokeStyle = "#ff69b4";
                ctx.lineWidth = 8;
                ctx.fillStyle = "yellow";
                ctx.strokeText("KO!", canvas.width / 2, canvas.height / 2);
                ctx.fillText("KO!", canvas.width / 2, canvas.height / 2);
            }
        
            if (performance.now() - koDisplayTime >= 2000) {
                const finalWinner = playersWithLives.length === 1 ? playersWithLives[0] : null;
                let winnerText = "KNOCKOUT!";
                let winnerColor = "red";
        
                if (finalWinner) {
                    winnerText = `${finalWinner.displayName.toUpperCase()} WON!`; // Use displayName for winner
                    winnerColor = finalWinner.name === "Assasin" ? "#00ffd0" :
                                  finalWinner.name === "Wu" ? "#ffa3ff" :
                                  finalWinner.name === "Darkrai" ? "#00ff00" : // Corrected Darkrai casing
                                  finalWinner.name === "Reaper" ? "#ff00ff" :
                                  "white";
                }
        
                ctx.font = "100px FightFont, sans-serif";
                ctx.fillStyle = winnerColor;
                ctx.strokeStyle = "#000";
                ctx.lineWidth = 4;
                ctx.strokeText(winnerText, canvas.width / 2, canvas.height / 2 + 60);
                ctx.fillText(winnerText, canvas.width / 2, canvas.height / 2 + 60);
            }
            requestAnimationFrame(loop); // Continue looping for game over screen
            return;
          }
        
          if (countdownTime > 0) {
            drawCountdown();
            requestAnimationFrame(loop); // Continue looping for countdown
            return;
          }
        
          if (!assetsLoaded) {
              requestAnimationFrame(loop); // Continue looping while assets load
              return;
          }
        
          ctx.clearRect(0, 0, canvas.width, canvas.height);
        
          if (bgImage.complete) {
            let currentDrawWidth = BG_TILE_WIDTH;
            let currentDrawHeight = BG_TILE_HEIGHT;
        
            if (bgImage.src.includes("Background5") ||
                bgImage.src.includes("Background6") ||
                bgImage.src.includes("Background7") ||
                bgImage.src.includes("Background8")
               ) {
                currentDrawWidth = canvas.width;
                currentDrawHeight = canvas.height;
            }
        
            for (let x = Math.floor(cameraX / currentDrawWidth) * currentDrawWidth; x < cameraX + canvas.width; x += currentDrawWidth)
                  ctx.drawImage(bgImage, x - cameraX, 0, currentDrawWidth, currentDrawHeight);
          }
        
          const activePlayersForCamera = players.filter(p => !p.dead && !p.isRespawning);
          if (activePlayersForCamera.length > 0) {
              const minPlayerX = Math.min(...activePlayersForCamera.map(p => p.x));
              const maxPlayerX = Math.max(...activePlayersForCamera.map(p => p.x));
              const targetX = (minPlayerX + maxPlayerX) / 2 - canvas.width / 2;
              cameraX += (targetX - cameraX) * 0.1;
        
              cameraX = Math.max(0, Math.min(cameraX, BG_TILE_WIDTH - canvas.width));
          } else {
              cameraX = 0;
          }
        
          // Player controls based on their ID from sessionStorage
          players.forEach(player => {
            const controls = playerControls[`P${players.indexOf(player) + 1}`];
            if (!controls) return; // Skip if no controls found for this player

            // Handle movement based on keyboard or gamepad input
            player.speedX = 0;
            if (keysDown[controls.moveLeft]) {
                player.speedX = -player.spd;
            } else if (keysDown[controls.moveRight]) {
                player.speedX = player.spd;
            }

            if (keysJustPressed[controls.join]) player.jump(); // "join" key is used for jump in-game

            // Special abilities
            if (player.name === "Knight" && keysDown[controls.attack1] && keysDown[controls.attack2]) {
                player.tryDefend();
            } else if (player.name === "Wu" && keysDown[controls.attack1] && keysDown[controls.attack2]) {
                const now = performance.now();
                if (checkStaminaForSpecial(player)) {
                    player.lockedUntil = 0;
                    player.attackCooldownUntil = 0;
                    player.stamina -= player.maxStamina * 0.1;
                    floatingTexts.push(new FloatingText("COMBO!", player.x, player.y - 100, "#ffa3ff"));
                }
            } else if (player.name === "Darkrai" && keysDown[controls.attack1] && keysDown[controls.attack2]) { // Corrected Darkrai casing
                const now = performance.now();
                if (now > player.superModeToggleCooldown) {
                    if (checkStaminaForSpecial(player) || player.isSuperMode) {
                        player.isSuperMode = !player.isSuperMode;
                        if (player.isSuperMode) {
                            player.stamina -= player.maxStamina * 0.1;
                            player.at1 *= 2;
                            player.at2 *= 2;
                            player.hp *= 2;
                            player.health = player.hp;
                            player.maxHealth = player.hp;
                            player.spd /= 2;
                            player.stam /= 2;
                            player.maxStamina = player.stam;
                            player.hitBox.xRel *= 2;
                            player.hitBox.yRel *= 2;
                            player.hitBox.w *= 2;
                            player.hitBox.h *= 2;
                            player.attackBoxes.forEach((box, index) => {
                                box.x = player.originalStats.attackBoxes[index].x;
                                box.y = player.originalStats.attackBoxes[index].y;
                                box.rx = player.originalStats.attackBoxes[index].rx;
                                box.ry = player.originalStats.attackBoxes[index].ry;
                            });
                            player.superModeDeactivationTime = now + 10000;
                            floatingTexts.push(new FloatingText("SUPER MODE!", player.x, player.y - 100, "gold"));
                        } else {
                            if (now < player.superModeDeactivationTime) {
                              player.stamina -= player.maxStamina * 0.1;
                            }
                            player.at1 = player.originalStats.at1;
                            player.at2 = player.originalStats.at2;
                            player.hp = player.originalStats.hp;
                            player.health = Math.min(player.health, player.hp);
                            player.maxHealth = player.hp;
                            player.spd = player.originalStats.spd;
                            player.stam = player.originalStats.stam;
                            player.maxStamina = player.stam;
                            player.hitBox.xRel = player.originalStats.hitBox.xRel;
                            player.hitBox.yRel = player.originalStats.hitBox.yRel;
                            player.hitBox.w = player.originalStats.hitBox.w;
                            player.hitBox.h = player.originalStats.hitBox.h;
                            player.attackBoxes.forEach((box, index) => {
                                box.x = player.originalStats.attackBoxes[index].x;
                                box.y = player.originalStats.attackBoxes[index].y;
                                box.rx = player.originalStats.attackBoxes[index].rx;
                                box.ry = player.originalStats.attackBoxes[index].ry;
                            });
                            player.superModeDeactivationTime = 0;
                            floatingTexts.push(new FloatingText("MODE OFF", player.x, player.y - 100, "grey"));
                        }
                        player.superModeToggleCooldown = now + 1000;
                    }
                }
            } else if (player.name === "Reaper" && keysDown[controls.attack1] && keysDown[controls.attack2]) {
                const now = performance.now();
                if (checkStaminaForSpecial(player) && !player.isDoubleSpeed) {
                    player.lockedUntil = 0;
                    player.attackCooldownUntil = 0;
                    player.stamina -= player.maxStamina * 0.1;
                    floatingTexts.push(new FloatingText("LIFE STEAL!", player.x, player.y - 100, "purple"));
                    
                    player.isDoubleSpeed = true;
                    player.spd = player.originalStats.spd * 2;
                    player.doubleSpeedEndTime = now + 5000;
                }
            } else {
                if (keysDown[controls.attack1]) player.tryAtk("Attack1");
                if (keysDown[controls.attack2]) player.tryAtk("Attack2");
            }
          });
        
          players.forEach(player => {
            player.update(dt);
            player.draw(cameraX);
          });
        
          // Draw bars dynamically based on actual player count
          players.forEach((player, index) => {
              const isRightAligned = index % 2 !== 0; // Alternates left/right alignment
              const yOffset = Math.floor(index / 2) * 220 + 40; // Adjusts y position for multiple pairs
              drawBars(40, yOffset, player, isRightAligned);
          });
        
          function checkAllCollisions() {
            for (let i = 0; i < players.length; i++) {
              for (let j = 0; j < players.length; j++) {
                if (i !== j && !players[i].dead && !players[j].dead) { // Ensure both attacker and defender are alive
                  const attacker = players[i];
                  const defender = players[j];
                  if (attacker.curA.startsWith("Attack")) {
                    let activeAttackBox = attacker.attackBoxes.find(box =>
                      (attacker.curA === "Attack1" && box.attack === 1) ||
                      (attacker.curA === "Attack2" && box.attack === 2)
                    );
                    
                    if ((attacker.name === "Darkrai" || attacker.name === "Reaper") && attacker.curA === "Attack2") { // Corrected Darkrai casing
                        activeAttackBox = attacker.attackBoxes.find(box => box.attack === 1);
                    }
                    if (!activeAttackBox) continue;
        
                    const ellipseX = activeAttackBox.worldX;
                    const ellipseY = activeAttackBox.worldY;
                    const ellipseWidth = activeAttackBox.rx * 2;
                    const ellipseHeight = activeAttackBox.ry * 2;
                    const ellipseAngle = 0;
        
                    const rectX = defender.x + defender.hitBox.xRel + (defender.hitBox.w / 2);
                    const rectY = defender.y + defender.hitBox.yRel + (defender.hitBox.h / 2);
                    const rectWidth = defender.hitBox.w;
                    const rectHeight = defender.hitBox.h;
                    const rectAngle = 0;
        
                    if (ellipseRectCollisionSAT(
                      ellipseX, ellipseY, ellipseWidth, ellipseHeight, ellipseAngle,
                      rectX, rectY, rectWidth, rectHeight, rectAngle
                    )) {
                        if (!attacker.targetsHitThisAttack.has(defender)) {
                            attacker.targetsHitThisAttack.add(defender);
        
                            let damage = attacker.curA === "Attack1" ? attacker.at1 : attacker.at2;
        
                            if (attacker.name === "Assasin" && attacker.curA === "Attack2" &&
                                attacker.y < groundY && attacker.vy > 0 && checkStaminaForSpecial(attacker)) {
                                damage = 20;
                                floatingTexts.push(new FloatingText("POUNCE!", players[0].x, players[0].y - 100, "#ffa3ff"));
                            }
        
                            if (attacker.name === "Wu" && keysDown["u"] && keysDown["o"] && checkStaminaForSpecial(attacker)) {
                                damage += 10;
                            }

                            // Tarzan superpower: double damage during dash attack
                            if (attacker.name === "Tarzan" && attacker.isDashing) {
                                damage *= 2;
                            }

                            // Knight superpower: 50% damage reduction when defending
                            if (defender.name === "Knight" && defender.isDefending) {
                                damage *= 0.5;
                                floatingTexts.push(new FloatingText(`BLOCKED! -${Math.round(damage)}`, defender.x, defender.y - 150, "cyan")); // Show reduced damage
                            }
        
                            if (attacker.name === "Reaper" && keysDown["7"] && keysDown["9"]) {
                                let stolenHealth = defender.health * 0.15;
                                // Knight superpower: doubled healing when defending
                                if (attacker.name === "Knight" && attacker.isDefending) { // This check should be on attacker, not defender, for healing
                                    stolenHealth *= 2;
                                }
                                attacker.health = Math.min(attacker.maxHealth, attacker.health + stolenHealth);
                                floatingTexts.push(new FloatingText(`+${Math.round(stolenHealth)} HP`, attacker.x, attacker.y - 150, "lime"));
                            }
        
                            const textX = defender.x - 5;
                            const textY = defender.y + defender.hitBox.yRel;
        
                            defender.pendingHurtAnim = {
                                type: "TakeHit",
                                startTime: performance.now() + 200
                            };
        
                            defender.health -= damage;
        
                            if (defender.health <= 0) {
                                defender.lives--;
                                if (defender.lives > 0) {
                                    defender.health = defender.maxHealth;
                                    defender.setA("Death", true);
                                    defender.isRespawning = true;
                                    defender.respawnTime = performance.now() + 5000;
                                } else {
                                    defender.health = 0;
                                    defender.dead = true;
                                    defender.setA("Death", true);
                                }
                            }
                            // Only show damage text if not blocked, or show reduced damage as above
                            if (!(defender.name === "Knight" && defender.isDefending)) {
                                floatingTexts.push(new FloatingText(`-${Math.round(damage)}`, textX, textY, "#ff5555"));
                            }
        
                            setTimeout(() => (defender.hitFlag = false), 200);
                        }
                    }
                  }
                }
              }
            }
          }
          checkAllCollisions();
        
          for (let i = floatingTexts.length - 1; i >= 0; i--) {
            if (!floatingTexts[i].draw(ctx)) {
              floatingTexts.splice(i, 1);
            }
          }
        
          if (debugMode) {
            ctx.fillStyle = "#222";
            ctx.fillRect(10, canvas.height - 50, 220, 40);
            ctx.fillStyle = "#fff";
            ctx.font = "16px monospace";
            ctx.fillText("Copy Debug Info", 20, canvas.height - 25);
        
            ctx.fillStyle = "white";
            ctx.font = "20px monospace";
            ctx.fillText(`Mouse X: ${Math.round(debugMouseX)}`, 20, canvas.height - 80);
            ctx.fillText(`Mouse Y: ${Math.round(debugMouseY)}`, 20, canvas.height - 60);
        
            ctx.strokeStyle = 'lime';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, groundY);
            ctx.lineTo(canvas.width, groundY);
            ctx.stroke();
        
            ctx.strokeStyle = 'yellow';
            ctx.lineWidth = 4;
            ctx.strokeRect(0, 0, canvas.width, canvas.height);
          }
        
          requestAnimationFrame(loop); // Ensure the loop continues
          for (const k in keysJustPressed) {
            delete keysJustPressed[k];
          }
        }
        
        function drawBars(initialX, y, pl, alignRight = false) {
          const spacing = 8;
          const scale = 2.5;
          const barW = HSB * scale;
          const barH = HSB * scale;
        
          let drawX = initialX;
        
          if (alignRight) {
            drawX = canvas.width - initialX - barW;
          }
        
          ctx.save();
        
          ctx.drawImage(healthImg, getBarFrame(pl.health, pl.maxHealth) * HSB, 0, HSB, HSB, drawX, y, barW, barH);
          ctx.drawImage(staminaImg, (pl.stamina >= Math.min(pl.at1SL, pl.at2SL) ? getBarFrame(pl.stamina, pl.maxStamina) : 5) * HSB, 0, HSB, HSB, drawX, y + barH + spacing, barW, barH);
          ctx.restore();
        
          ctx.save();
          ctx.font = "30px FightFont, sans-serif";
          ctx.fillStyle = "white";
          ctx.strokeStyle = "black";
          ctx.lineWidth = 2;
          
          let livesTextDrawX;
          // Use displayName for the health bar text
          let livesText = `${pl.displayName.toUpperCase()} LIVES: ${pl.lives}`; 

          if (alignRight) {
            livesTextDrawX = drawX - 10;
            ctx.textAlign = "right";
          } else {
            livesTextDrawX = drawX + barW + 10;
            ctx.textAlign = "left";
          }
          
          const livesTextY = y + barH / 2 + 15;
        
          ctx.strokeText(livesText, livesTextDrawX, livesTextY);
          ctx.fillText(livesText, livesTextDrawX, livesTextY);
          ctx.restore();
        
          function getBarFrame(val, max) {
            const p = (val / max) * 100;
            return p <= 0 ? 5 : p <= 20 ? 4 : p <= 40 ? 3 : p <= 60 ? 2 : p <= 80 ? 1 : 0;
          }
          ctx.imageSmoothingEnabled = false;

        }
        
        })();
    </script>
</body>

</html>
